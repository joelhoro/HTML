<!-- <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script> -->
<script type="text/javascript" src="../lib/d3.v3.min.js"></script>
<script src="../lib/d3.tip.v0.6.3.js"></script>
<script type="text/javascript" src="keybindings.js"></script>

<style>

.line {
  fill: none;
  stroke-width: 2px;
}

ul {
	list-style-type: none;
}
.axis path,
.axis line {
    fill: none;
    stroke: #dddddd;
    shape-rendering: crispEdges;
    stroke-width: 2px;
}

.axis text {
    font-family: sans-serif;
    font-size: 13px;
}

text.edited {
	font-size: 26px;
	background-color: blue;
	font-weight: bold;
}

.square {
	display: inline-block;
    /*position: absolute;*/
    left: 0;
    top: 0;
    width: 12px;
    height: 12px;
    border-radius: 2px;
}
.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0,0,0,0.7	);
  color: white;
  border-radius: 10px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}

.d3-tip ul {
	margin-left: -40px;
}
</style>

<body>
<p><button onclick='refresh()'>Randomize</button><span id='t'></span>
<p><svg width=1000 height=500>

</svg>

</body>


<script type="text/javascript">

"use strict";

var maxX = 0;

function getChart() {
	var r = () => Math.random()*0+1;
	xs = d3.range(0,2*Math.PI + maxX++,0.3);
	var ys = xs.map(x => Math.sin(x-r())*r());
	var ys2 = xs.map(x => Math.sin(x*x+r())/3*r());
	var ys3 = xs.map(x => Math.cos(x/r())/2*r());
	var rows = [ys,ys2,ys3];

	// transforming the data into d3 data
	var data = d3.zip(xs,d3.zip(...rows)).map(p => ({ x: p[0], ys: p[1] }));
	return data;	
}



function getChart() {
	return {

		series : [ "Jan", "Feb", "Mar", "Apr", "May" ],
		data :  [
					[ 3,6, 3.5, 5, 4.5],
					[ 2,4, 5, 3, 4]
				],
		labels: [ "Series A", "Series B" ],
		options : {
			padding: 50,
			tooltipFn: (d,chart, settings) => {
			  	var j = 0;
			    return d.x + "<ul>" + d.ys.map(y => "<li><span class='square' style='background-color:"+settings.colors[j]+"'></span> "
			     + chart.labels[j++]+": " + y
			      ).join("\n") + "</ul>";
			  }
		}

	}
}

var globalSettings = { 
	colors :
		[
			"#678DBF",
			"#73B03A",
			"#B274D0",
			"#BD8C2D",
			"#CB5589",
			"#47A878",
			"#D15441"
		]
}


var translate = (x,y) => "translate(" + x + "," + y + ")";

function start() {

	d3.select("#t").text(new Date().toString());
	
	var svg = d3.select("svg");

	var w = svg.attr("width");
	var h = svg.attr("height");

	var chart = getChart();

	var padding = chart.options.padding;
	var labels = chart.labels;
	var tooltipFn = d => chart.options.tooltipFn(d, chart, globalSettings);
	var indices = d3.range(chart.data.length);
	var series = d3.range(chart.series.length);

	var counter = 0;
	var d3data = d3
		.zip(chart.series,d3.zip(...chart.data))
		.map(p => ({ 
			x: p[0], 
			ys: p[1], 
			edited: p[1].map(x => (counter++==0))
		}));

	var x = d3.scale.ordinal()
		.domain(chart.series)
		.range(series.map(i => padding + i*(w-padding*2)/(series.length-1)));

	var y = d3.scale.linear()
		.domain([
			d3.min(chart.data, d => Math.min(...d)),
			d3.max(chart.data, d => Math.max(...d)),
			])
		.range([h-padding,padding]);

	var i =0;


	var margin = 0;	 
	var xAxis = d3.svg.axis()
	                  .scale(x)
	                  .orient("bottom")
					  .innerTickSize(-(h-padding*2+margin))
					  .outerTickSize(0)
				      .tickPadding(30)
	                  ;	
	var yAxis = d3.svg.axis()
	                  .scale(y)
	                  .orient("left")
	                  .innerTickSize(-(w-padding*2+margin))
			   	      .outerTickSize(0)
				      .tickPadding(10)
	                  ;	

	// x-axis                
	svg
		.append("g")
		.attr("class","x axis")
		.attr("transform", translate(0,h-padding+margin))
		.call(xAxis)	;                

	// y-axis
	svg
		.append("g")
		.attr("class","y axis")
		.attr("transform", translate(padding-margin,0))
		.call(yAxis)	;                

	// splines
	var lines = indices.map(i =>
		d3.svg.line()
		.interpolate("cardinal")    
	    .x(d => x(d.x))
	    .y(d => y(d.ys[i]))
	    );

	var colors = globalSettings.colors;
	var addPaths = (k,c) => c
		  .attr("d",lines[k])
		  .attr("class", "line") 
		  .attr("stroke", colors[k])
	
	var curves = indices.map(i => 
		addPaths(i,svg
		  .append("path")
		  .datum(d3data)))

	// tooltip
	var tip = d3.tip()
	  .attr('class', 'd3-tip')
	  .offset([-10, 0])
	  .html(tooltipFn)

	svg.call(tip);

	var createCircles = function(k,obj) { 
		obj
			.attr("transform", d => translate(x(d.x),y(d.ys[k])))
			//.append("g")
			.on('mouseover', function(d,idx) { 
				d3.select(this.childNodes[0])
				.attr("fill", "white")
				.attr("stroke", colors[k]);
				tip.show(d);
			})
			.on('mouseout', function(d,idx) { 
				d3.select(this.childNodes[0])
				.attr("fill", colors[k])
				.attr("stroke", null)
				tip.hide();
			}) }
	var updateCircles = (k,obj) => {
		obj
			.selectAll("circle")
			.data(d =>  [
				 { r: 4, fill: colors[k], editMode: false }, 
				 { r: 20, fill: "transparent", editMode: false },
				 { r: 25, fill: "transparent", editMode: d.edited[k] },
				 ])
			.enter()
			.append("circle")
			.attr("fill", d => d.fill)
			.attr("stroke", d => d.editMode ? "black" : "transparent" )
			.attr("r", d => d.r)
	}

	var dots=[];
	// little circles around data
	indices.map(i => { 
		dots[i] = svg
			.append("g")
			.selectAll("circle")
			.data(d3data)
			.enter()
			.append("g");
		createCircles(i,dots[i]);
		updateCircles(i,dots[i]);
	}
	);

	var activeElement = 0;
	var activeSeries = 0;

	function move(changeElement,shiftY) {
		var animationDelay = 200;
		return function(event) {
	        event.preventDefault();
			
			var factor = 1;
			if(event.shiftKey) factor= 0.2;
			if(event.ctrlKey) factor = 5;

			// switch activelement as possible
			d3data[activeElement].edited[0] = false;
			activeElement += changeElement;
			activeElement = Math.min(Math.max(activeElement,0), d3data.length-1);
			d3data[activeElement].edited[0] = true;
			d3data[activeElement].ys[0] += shiftY*0.1*factor;

			// change classes on axis
			var delay = animationDelay*Math.sqrt(factor);
			d3.selectAll(d3.selectAll(".x .tick text")[0]).classed("edited",false)
			d3.select(d3.selectAll(".x .tick text")[0][activeElement]).classed("edited", true);
			indices.forEach(i =>  {
				dots[i]
					.data(d3data)
					.transition()
	   			    .duration(delay)
					.attr("transform", d => translate(x(d.x),y(d.ys[i])))
				updateCircles(i,dots[i]);
				});
			indices.forEach(i => 
				addPaths(i,curves[i]
				  .datum(d3data)
				  .transition()
	   			  .duration(delay)
				)
			  );
	    };

	}

	d3.select('body').call(d3.keybinding()
	    .on('←', move(-1, 0))
	    .on('↑', move(0,1))
	    .on('→', move(1,0))
	    .on('↓', move(0,-1)));

	// svg
	// 	.append("g")
	// 	.selectAll("line")
	// 	.data(data)
	// 	.enter()
	// 	.append("line")
	// 	.attr("x1", d => x(d.x))
	// 	.attr("y1", 0)
	// 	.attr("x2", d => x(d.x))
	// 	.attr("y2", h-padding)
	// 	.attr("stroke", "transparent")
	// 	.attr("stroke-width", 5)
	// 	.on("mouseover", function(d) {
	// 		tip.show(d);
	// 	})

}

function refresh() {
	var svg = d3.select("svg");
	var data = getChart();
	var indices = [0,1,2];

	y.domain([
			d3.min(data, d => Math.min(...d.ys)),
			d3.max(data, d => Math.max(...d.ys)),
			])
	x.domain([d3.min(xs),d3.max(xs)])

	svg.select(".y.axis")
							.transition()
							.duration(1000)
							.call(yAxis);
	svg.select(".x.axis")
							.transition()
							.duration(1000)
							.call(xAxis);


	var lines = indices.map(i =>
		d3.svg.line()
		.interpolate("cardinal")    
	    .x(function(d) { return x(d.x); })
	    .y(function(d) { return y(d.ys[i]); }) );
	
	indices.forEach(i => 
		svg
		  .selectAll("#curve"+i)
		  .datum(data)
		  .transition()
		  .duration(1000)
		 // .attr("transform", translate(padding,padding))
		  .attr("d",lines[i])
		  .attr("class", "line") 
		  .attr("stroke", colors[i])
	  );


	var r = Math.random;
	scatterData.map(p => { p.x *= (0.9+r()/2); p.y *= (0.65+r()/2);})
	svg
		.select("#scatterpoints")
		.selectAll("image")
		.data(scatterData)
		.transition()
		.duration(1000)
		.attr("x", d => x(d.x))
		.attr("y", d => y(d.y))



	indices.map(i => 
	{
		var points = svg
			.selectAll("#dots"+i)
			.data(data);
		points.enter().append("circle");
		points
			.transition()
			.duration(1000)
			.attr("transform", d => translate(x(d.x),y(d.ys[i])))
		points
			.exit()
			.transition()
			.duration(1000)
			.remove()
	});
}

start();

//setInterval(refresh, 1000)

</script>
