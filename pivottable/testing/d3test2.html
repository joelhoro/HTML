fd3<!-- <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script> -->
<script type="text/javascript" src="../lib/d3.v3.min.js"></script>
<script src="../lib/d3.tip.v0.6.3.js"></script>
<script type="text/javascript" src="keybindings.js"></script>

<style>

.line {
  fill: none;
  stroke-width: 2px;
}

ul {
	list-style-type: none;
}
.axis path,
.axis line {
    fill: none;
    stroke: #dddddd;
    shape-rendering: crispEdges;
    stroke-width: 2px;
}

.axis text {
    font-family: sans-serif;
    font-size: 13px;
}

text.edited {
	font-size: 26px;
	background-color: blue;
	font-weight: bold;
}

.square {
	display: inline-block;
    /*position: absolute;*/
    left: 0;
    top: 0;
    width: 12px;
    height: 12px;
    border-radius: 2px;
}
.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0,0,0,0.7	);
  color: white;
  border-radius: 10px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}

.d3-tip ul {
	margin-left: -40px;
}
</style>

<body>
<p><button onclick='refresh()'>Randomize</button><span id='t'></span>
<p><svg width=1000 height=500>

</svg>

</body>

<script type="text/javascript">

var maxX = 0;

function getChart() {
	var r = () => Math.random()*0+1;
	xs = d3.range(0,2*Math.PI + maxX++,0.3);
	var ys = xs.map(x => Math.sin(x-r())*r());
	var ys2 = xs.map(x => Math.sin(x*x+r())/3*r());
	var ys3 = xs.map(x => Math.cos(x/r())/2*r());
	var rows = [ys,ys2,ys3];

	// transforming the data into d3 data
	var data = d3.zip(xs,d3.zip(...rows)).map(p => ({ x: p[0], ys: p[1] }));
	return data;	
}



function getChart() {
	return {

		series : [ "Jan", "Feb", "Mar", "Apr", "May" ],
		data :  [
					[ 3,6, 3.5, 5, 4.5],
					[ 2,4, 5, 3, 4]
				],
		labels: [ "Series A", "Series B" ],
		options : {
			padding: 50
		}

	}
}




var translate = (x,y) => "translate(" + x + "," + y + ")";

function start() {

	d3.select("#t").text(new Date().toString());
	
	var svg = d3.select("svg");

	var w = svg.attr("width");
	var h = svg.attr("height");

	var chart = getChart();
	var padding = chart.options.padding;
	var labels = chart.labels;
	var indices = d3.range(chart.data.length);
	var series = d3.range(chart.series.length);

	var d3data = d3.zip(chart.series,d3.zip(...chart.data)).map(p => ({ x: p[0], ys: p[1] }));
	x = d3.scale.ordinal()
		.domain(chart.series)
		.range(series.map(i => padding + i*(w-padding*2)/(series.length-1)));

	y = d3.scale.linear()
		.domain([
			d3.min(chart.data, d => Math.min(...d)),
			d3.max(chart.data, d => Math.max(...d)),
			])
		.range([h-padding,padding]);

	var i =0;
	colors = 
		[
			"#678DBF",
			"#73B03A",
			"#B274D0",
			"#BD8C2D",
			"#CB5589",
			"#47A878",
			"#D15441"
		];

	var margin = 0;	 
	xAxis = d3.svg.axis()
	                  .scale(x)
	                  .orient("bottom")
					  .innerTickSize(-(h-padding*2+margin))
					  .outerTickSize(0)
				      .tickPadding(30)
	                  ;	
	yAxis = d3.svg.axis()
	                  .scale(y)
	                  .orient("left")
	                  .innerTickSize(-(w-padding*2+margin))
			   	      .outerTickSize(0)
				      .tickPadding(10)
	                  ;	

	// x-axis                
	svg
		.append("g")
		.attr("class","x axis")
		.attr("transform", translate(0,h-padding+margin))
		.call(xAxis)	;                

	// y-axis
	svg
		.append("g")
		.attr("class","y axis")
		.attr("transform", translate(padding-margin,0))
		.call(yAxis)	;                

	// splines
	var lines = indices.map(i =>
		d3.svg.line()
		.interpolate("cardinal")    
	    .x(d => x(d.x))
	    .y(d => y(d.ys[i]))
	    );
	
	var curves = indices.map(i => 
		svg
		  .append("path")
		  .datum(d3data)
		 // .attr("transform", translate(padding,padding))
		  .attr("d",lines[i])
		  .attr("class", "line") 
		  .attr("stroke", colors[i])
	  );

	// tooltip
	var tip = d3.tip()
	  .attr('class', 'd3-tip')
	  .offset([-10, 0])
	  .html(function(d) {
	  	var j = 0;
	    return d.x + "<ul>" + d.ys.map(y => "<li><span class='square' style='background-color:"+colors[j]+"'></span> "
	     + labels[j++]+": " + y
	      ).join("\n") + "</ul>";
	  })

	svg.call(tip);

	var dots=[];
	// little circles around data
	indices.map(i => { 
		dots[i] = svg
		.append("g")
		.selectAll("circle")
		.data(d3data)
		.enter()
		.append("g");
		dots[i]
		.attr("transform", d => translate(x(d.x),y(d.ys[i])))
		.append("g")
		.on('mouseover', function(d,idx) { 
			d3.select(this.childNodes[0])
			.attr("fill", "white")
			.attr("stroke", colors[i]);
			tip.show(d);
		})
		.on('mouseout', function(d,idx) { 
			d3.select(this.childNodes[0])
			.attr("fill", colors[i])
			.attr("stroke", null)
			tip.hide();
		})
		.selectAll("circle")
		.data(d => [//{ r: 16, fill: 'transparent', stroke: 'black' },
			 { r: 4, fill: colors[i], data: d }, { r: 20, fill: "transparent", data: d }])
		.enter()
		.append("circle")
		.attr("fill", d => d.fill)
		.attr("stroke", d => d.stroke)
		.attr("r", d => d.r)
		}
		);

	var activeElement = 0;

	function move(changeElement,shiftY) {
		return function(event) {
	        event.preventDefault();
			// console.debug("Shifting");
			// scatterData[0].y += 0.025 * shift;
			// svg
			// 	.select("#scatterpoints")
			// 	.selectAll("image")
			// 	.data(scatterData)
			// 	.transition()
			// 	.duration(100)
			// 	.attr("x", d => x(d.x))
			// 	.attr("y", d => y(d.y))
			var factor = 1;
			if(event.shiftKey) factor= 0.2;
			if(event.ctrlKey) factor = 5;

			activeElement += changeElement;
			activeElement = Math.min(Math.max(activeElement,0), d3data.length-1);
			d3.selectAll(d3.selectAll(".x .tick text")[0]).classed("edited",false)
			d3.select(d3.selectAll(".x .tick text")[0][activeElement]).classed("edited", true);

			console.debug(activeElement);
			d3data[activeElement].ys[0] += shiftY*0.1*factor;

			var lines = indices.map(i =>
				d3.svg.line()
				.interpolate("cardinal")    
			    .x(function(d) { return x(d.x); })
			    .y(function(d) { return y(d.ys[i]); }) );
			indices.forEach(i => 
				curves[i]
				  .datum(d3data)
				  .transition()
				  .duration(100)
				 // .attr("transform", translate(padding,padding))
				  .attr("d",lines[i])
				  .attr("class", "line") 
				  .attr("stroke", colors[i])
			  );

			indices.forEach(i => 
				dots[i]
				//	.selectAll("circle")
					.data(d3data)
					.transition()
	   			    .duration(100)
					.attr("transform", d => translate(x(d.x),y(d.ys[i])))

				);
	    };

	}

	d3.select('body').call(d3.keybinding()
	    .on('←', move(-1, 0))
	    .on('↑', move(0,1))
	    .on('→', move(1,0))
	    .on('↓', move(0,-1)));

	// svg
	// 	.append("g")
	// 	.selectAll("line")
	// 	.data(data)
	// 	.enter()
	// 	.append("line")
	// 	.attr("x1", d => x(d.x))
	// 	.attr("y1", 0)
	// 	.attr("x2", d => x(d.x))
	// 	.attr("y2", h-padding)
	// 	.attr("stroke", "transparent")
	// 	.attr("stroke-width", 5)
	// 	.on("mouseover", function(d) {
	// 		tip.show(d);
	// 	})

}

function refresh() {
	var svg = d3.select("svg");
	var data = getChart();
	var indices = [0,1,2];

	y.domain([
			d3.min(data, d => Math.min(...d.ys)),
			d3.max(data, d => Math.max(...d.ys)),
			])
	x.domain([d3.min(xs),d3.max(xs)])

	svg.select(".y.axis")
							.transition()
							.duration(1000)
							.call(yAxis);
	svg.select(".x.axis")
							.transition()
							.duration(1000)
							.call(xAxis);


	var lines = indices.map(i =>
		d3.svg.line()
		.interpolate("cardinal")    
	    .x(function(d) { return x(d.x); })
	    .y(function(d) { return y(d.ys[i]); }) );
	
	indices.forEach(i => 
		svg
		  .selectAll("#curve"+i)
		  .datum(data)
		  .transition()
		  .duration(1000)
		 // .attr("transform", translate(padding,padding))
		  .attr("d",lines[i])
		  .attr("class", "line") 
		  .attr("stroke", colors[i])
	  );


	var r = Math.random;
	scatterData.map(p => { p.x *= (0.9+r()/2); p.y *= (0.65+r()/2);})
	svg
		.select("#scatterpoints")
		.selectAll("image")
		.data(scatterData)
		.transition()
		.duration(1000)
		.attr("x", d => x(d.x))
		.attr("y", d => y(d.y))



	indices.map(i => 
	{
		var points = svg
			.selectAll("#dots"+i)
			.data(data);
		points.enter().append("circle");
		points
			.transition()
			.duration(1000)
			.attr("transform", d => translate(x(d.x),y(d.ys[i])))
		points
			.exit()
			.transition()
			.duration(1000)
			.remove()
	});
}

start();

//setInterval(refresh, 1000)

</script>
